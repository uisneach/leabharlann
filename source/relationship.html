---
layout: layout.njk
---
<div class="container mt-4">
  <h1>Create Relationship</h1>
  <div class="row">
    <div class="col-md-6">
      <h3>Source Node</h3>
      <div class="card mb-3">
        <div class="card-body">
          <p><strong>Type:</strong> <span id="fromType"></span></p>
          <p><strong>ID:</strong> <span id="fromId"></span></p>
          <p><strong>Name:</strong> <span id="fromName"></span></p>
        </div>
      </div>
    </div>
    <div class="col-md-6">
      <h3>Target Node</h3>
      <form id="createRelationshipForm">
        <div class="mb-3">
          <label for="toNodeSearch" class="form-label">Search Target Node</label>
          <div class="input-group">
            <input type="text" class="form-control" id="toNodeSearch" placeholder="Enter search value (name, title, or ID)" required>
            <span id="nodeStatus" class="input-group-text"></span>
          </div>
          <ul id="searchResults" class="list-group mt-2" style="display: none; max-height: 200px; overflow-y: auto;"></ul>
          <input type="hidden" id="toId" required>
          <input type="hidden" id="toLabel" required>
        </div>
        <div class="mb-3">
          <label for="relType" class="form-label">Relationship Type</label>
          <input type="text" class="form-control" id="relType" placeholder="e.g., WROTE" required>
        </div>
        <div id="errorMessage" class="text-danger mb-3" style="display: none;"></div>
        <button type="submit" class="btn btn-primary" id="submitButton" disabled>Create Relationship</button>
        <a href="index.html" class="btn btn-link">Cancel</a>
      </form>
    </div>
  </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>
<script>
  let propertyCount = 0;
  let isTargetValid = false;

  function debounce(func, delay) {
    let timeout;
    return (...args) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => func(...args), delay);
    };
  }

  async function loadSourceNode() {
    const urlParams = new URLSearchParams(window.location.search);
    const fromId = urlParams.get('fromId');
    if (!fromId) {
      document.querySelector('.container').innerHTML = '<p class="text-danger">Invalid source node parameters</p>';
      return;
    }
    try {
      const response = await getNode(fromId);
      if (response.status === 401) {
        localStorage.removeItem('token');
        localStorage.removeItem('refreshToken');
        window.location.href = 'index.html';
        return;
      }
      if (!response.ok) throw new Error(`Error ${response.status}: ${await response.text()}`);
      const data = await response.json();
      if (!data) throw new Error('Node not found');
      document.getElementById('fromId').textContent = data.id;
      document.getElementById('fromName').textContent = data.properties.name || data.properties.title || data.properties.nodeId || data.id;
    } catch (error) {
      document.querySelector('.container').innerHTML = `<p class="text-danger">Error loading source node: ${error.message}</p>`;
    }
  }

  const performSearch = debounce(async (query) => {
    const resultsList = document.getElementById('searchResults');
    const nodeStatus = document.getElementById('nodeStatus');
    const errorMessage = document.getElementById('errorMessage');

    resultsList.innerHTML = '';
    resultsList.style.display = 'none';
    document.getElementById('toId').value = '';
    document.getElementById('toLabel').value = '';
    isTargetValid = false;
    nodeStatus.textContent = '';
    document.getElementById('submitButton').disabled = true;
    errorMessage.style.display = 'none';

    if (query.length < 2) {
      return;
    }

    nodeStatus.textContent = 'ðŸ”';

    try {
      const searchResponse = await search(query);
      if (!searchResponse.ok) {
        throw new Error(`Search failed with status: ${searchResponse.status}`);
      }

      const nodes = await searchResponse.json();

      if (nodes.length === 0) {
        nodeStatus.textContent = '';
        return;
      }

      const fullNodesPromises = nodes.map(async (node) => {
        try {
          const nodeResponse = await getNode(node.id);
          if (!nodeResponse.ok) return null;
          return await nodeResponse.json();
        } catch {
          return null;
        }
      });

      const fullNodes = await Promise.all(fullNodesPromises);
      const filteredFullNodes = fullNodes.filter(node => node !== null);

      if (filteredFullNodes.length > 0) {
        resultsList.innerHTML = '';
        filteredFullNodes.forEach(fullNode => {
          const label = fullNode.labels.find(l => l !== 'Entity') || fullNode.labels[0] || 'Unknown';
          const displayName = fullNode.properties.display_name || fullNode.properties.name || fullNode.properties.title || fullNode.properties.nodeId || fullNode.id;

          const li = document.createElement('li');
          li.className = 'list-group-item list-group-item-action';
          li.textContent = `${label}: ${displayName}`;
          li.dataset.nodeId = fullNode.id;
          li.dataset.nodeLabel = label;

          li.addEventListener('click', () => {
            document.getElementById('toId').value = li.dataset.nodeId;
            document.getElementById('toLabel').value = li.dataset.nodeLabel;
            document.getElementById('toNodeSearch').value = li.textContent;
            resultsList.innerHTML = '';
            resultsList.style.display = 'none';
            isTargetValid = true;
            nodeStatus.textContent = 'âœ”';
            nodeStatus.className = 'input-group-text text-success';
            document.getElementById('submitButton').disabled = false;
          });

          resultsList.appendChild(li);
        });
        resultsList.style.display = 'block';
      }
    } catch (error) {
      console.error('Search error:', error);
      errorMessage.style.display = 'block';
      errorMessage.textContent = `Search failed: ${error.message}`;
    } finally {
      if (!isTargetValid) {
        nodeStatus.textContent = '';
      }
    }
  }, 300);

  document.getElementById('toNodeSearch').addEventListener('input', e => {
    performSearch(e.target.value.trim());
  });

  document.getElementById('createRelationshipForm').addEventListener('submit', async e => {
    e.preventDefault();
    const errorMessage = document.getElementById('errorMessage');
    errorMessage.style.display = 'none';
    const urlParams = new URLSearchParams(window.location.search);
    const fromType = urlParams.get('fromType');
    const fromId = urlParams.get('fromId');
    const toLabel = document.getElementById('toLabel').value.trim();
    const toId = document.getElementById('toId').value.trim();
    const relType = document.getElementById('relType').value.trim();
    const relProps = {};
    let invalidProp = false;

    document.querySelectorAll('.property-row').forEach(row => {
      const nameInput = row.querySelector('input[name^="prop-name-"]');
      const valueInput = row.querySelector('input[name^="prop-value-"]');
      const name = nameInput.value.trim();
      const value = valueInput.value.trim();
      if (name) {
        if (/[^a-zA-Z0-9_]/.test(name)) {
          invalidProp = true;
          return;
        }
        relProps[name] = value || null;
      }
    });

    if (!fromType || !fromId || !toLabel || !toId || !relType) {
      errorMessage.style.display = 'block';
      errorMessage.textContent = 'All fields (source type, source ID, target label, target ID, relationship type) are required';
      return;
    }
    if (/[^a-zA-Z0-9_]/.test(relType) || /[^a-zA-Z0-9_]/.test(toLabel)) {
      errorMessage.style.display = 'block';
      errorMessage.textContent = 'Relationship type and target label must contain only letters, numbers, or underscores';
      return;
    }
    if (invalidProp) {
      errorMessage.style.display = 'block';
      errorMessage.textContent = 'Property names must contain only letters, numbers, or underscores';
      return;
    }
    if (!isTargetValid) {
      errorMessage.style.display = 'block';
      errorMessage.textContent = 'Please select a valid target node';
      return;
    }
    try {
      const response = await createRelation(fromId, toId, relType);
      const data = await response.json();
      if (!response.ok) throw new Error(data.error.message || 'Failed to create relationship');
      errorMessage.style.display = 'none';
      window.location.href = `/leabharlann/info/index.html?label=${encodeURIComponent(fromType)}&id=${encodeURIComponent(fromId)}`;
    } catch (error) {
      errorMessage.style.display = 'block';
      errorMessage.textContent = error.message;
    }
  });

  window.addEventListener('DOMContentLoaded', () => {
    loadSourceNode();
  });
</script>
