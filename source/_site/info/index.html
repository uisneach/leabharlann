<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>An Leabharlann Ghealach</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
  <link rel="stylesheet" href="/leabharlann/css/style.css">
  <link rel="icon" type="image/x-icon" href="https://uisneac.com/images/Gold-Celtic-Design.png">
</head>
  <body>
    <script src="/leabharlann/scripts/utils.js"></script>
    <script src="/leabharlann/scripts/API.js"></script>
      <header>
    <nav class="navbar navbar-expand-lg">
      <a class="navbar-brand" href="/leabharlann/index.html">
        <img src="https://uisneac.com/images/Gold-Celtic-Design.png" alt="Logo" width="32" height="32" class="d-inline-block align-text-top">
        An Leabharlann Ghealach
      </a>
      <form id="search-form" class="d-flex mx-3" style="flex:1;">
        <input id="search-input" class="form-control me-2" type="search" placeholder="Search the database…" aria-label="Search">
        <button class="btn btn-light" type="submit">Search</button>
      </form>
      <ul class="navbar-nav">
        <li class="nav-item">
          <a class="nav-link" id="profileMenu" role="button">Account</a>
        </li>
      </ul>
    </nav>
    <div class="modal fade" id="loginModal" tabindex="-1" aria-labelledby="loginModalLabel" aria-hidden="true">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="loginModalLabel">Log In</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <form id="loginForm">
              <div class="mb-3">
                <label for="username" class="form-label">Username</label>
                <input type="text" class="form-control" id="username" required>
              </div>
              <div class="mb-3">
                <label for="password" class="form-label">Password</label>
                <input type="password" class="form-control" id="password" required>
              </div>
              <div id="errorMessage" class="text-danger mb-3" style="display: none;"></div>
              <button type="submit" class="btn btn-primary">Log In</button>
              <a href="register.html" class="btn btn-link">Register</a>
            </form>
          </div>
        </div>
      </div>
    </div>
    <div class="modal fade" id="searchResultsModal" tabindex="-1" aria-labelledby="searchResultsModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-lg">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="searchResultsModalLabel">Search Results</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <div id="searchResults" class="list-group"></div>
          </div>
        </div>
      </div>
    </div>
    <script>
      // Helper: parse JWT payload safely
      function parseJwt(token) {
        try {
          const part = token.split('.')[1];
          return JSON.parse(atob(part));
        } catch (e) {
          return {};
        }
      }

      function updateProfileMenu(username) {
        const profileMenu = document.getElementById('profileMenu');
        if (!profileMenu) return;
        const navItem = profileMenu.parentElement;
        profileMenu.textContent = username;
        profileMenu.classList.add('dropdown-toggle');
        profileMenu.setAttribute('data-bs-toggle', 'dropdown');

        // Remove any existing dropdown menu
        const existingDropdown = navItem.querySelector('.dropdown-menu');
        if (existingDropdown) existingDropdown.remove();

        // Build dropdown
        const dropdown = document.createElement('ul');
        dropdown.className = 'dropdown-menu dropdown-menu-end';

        // Profile / account link (optional; you can add more items)
        const profileItem = document.createElement('li');
        const profileLink = document.createElement('a');
        profileLink.className = 'dropdown-item';
        profileLink.href = 'account.html';
        profileLink.textContent = 'Account';
        profileItem.appendChild(profileLink);
        dropdown.appendChild(profileItem);

        // Logout
        const logoutItem = document.createElement('li');
        const logoutLink = document.createElement('a');
        logoutLink.className = 'dropdown-item';
        logoutLink.href = '#';
        logoutLink.textContent = 'Log out';
        logoutLink.addEventListener('click', e => {
          e.preventDefault();
          localStorage.removeItem('token');
          localStorage.removeItem('refreshToken');
          // revert profile menu to default
          profileMenu.textContent = 'Account';
          profileMenu.classList.remove('dropdown-toggle');
          profileMenu.removeAttribute('data-bs-toggle');
          navItem.querySelector('.dropdown-menu')?.remove();
          document.dispatchEvent(new Event('authChange'));
        });
        logoutItem.appendChild(logoutLink);
        dropdown.appendChild(logoutItem);

        navItem.appendChild(dropdown);

        // notify other parts of app
        document.dispatchEvent(new Event('authChange'));
      }

      async function checkAuthStatus() {
        let token = localStorage.getItem('token');
        const refreshToken = localStorage.getItem('refreshToken');

        if (!token) {
          // ensure menu shows default
          const profileMenu = document.getElementById('profileMenu');
          if (profileMenu) {
            profileMenu.textContent = 'Account';
            profileMenu.classList.remove('dropdown-toggle');
            profileMenu.removeAttribute('data-bs-toggle');
            const navItem = profileMenu.parentElement;
            navItem.querySelector('.dropdown-menu')?.remove();
          }
          document.dispatchEvent(new Event('authChange'));
          return;
        }

        try {
          let payload = parseJwt(token);
          // if token expired and we have a refreshToken, try refreshing
          if (payload && payload.exp && Date.now() >= payload.exp * 1000) {
            if (!refreshToken) throw new Error('Token expired');
            const res = await fetch(`${API_BASE}/refresh`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ refreshToken })
            });
            const data = await res.json();
            if (!res.ok) throw new Error(data?.error?.message || 'Token refresh failed');
            // store the new token (and refresh token if returned)
            if (data.token) {
              localStorage.setItem('token', data.token);
              token = data.token;
              payload = parseJwt(token);
            }
            if (data.refreshToken) localStorage.setItem('refreshToken', data.refreshToken);
          }

          // Finally update menu with username (if available)
          const username = payload.username || payload.sub || 'User';
          updateProfileMenu(username);
        } catch (e) {
          console.error('Auth check error:', e);
          localStorage.removeItem('token');
          localStorage.removeItem('refreshToken');
          document.dispatchEvent(new Event('authChange'));
        }
      }

      function displaySearchResults(results, query) {
        const searchResults = document.getElementById('searchResults');
        if (!searchResults) return;
        searchResults.innerHTML = '';

        if (!Array.isArray(results) || results.length === 0) {
          const p = document.createElement('p');
          p.className = 'text-muted';
          p.textContent = `No results found for "${query}"`;
          searchResults.appendChild(p);
        } else {
          results.forEach(node => {
            const label = (node.labels || []).find(l => l !== 'Entity') || 'Node';
            const displayName = (node.properties && (node.properties.display_name || node.properties.name || node.properties.title)) || node.id || 'Unknown';
            const item = document.createElement('a');
            item.className = 'list-group-item list-group-item-action';
            item.href = `info/index.html?type=${encodeURIComponent(label)}&id=${encodeURIComponent(node.id)}`;
            item.innerHTML = `<strong>${label}</strong>: ${escapeHtml(String(displayName))}`;
            searchResults.appendChild(item);
          });
        }

        const modalEl = document.getElementById('searchResultsModal');
        if (modalEl && window.bootstrap && typeof window.bootstrap.Modal === 'function') {
          const modal = new bootstrap.Modal(modalEl);
          modal.show();
        }
      }

      // Escape HTML text to avoid injecting markup.
      function escapeHtml(str) {
        return str.replace(/[&<>"']/g, function (m) {
          return ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' })[m];
        });
      }

      function attachEventListeners() {
        const profileMenu = document.getElementById('profileMenu');
        const loginForm = document.getElementById('loginForm');
        const searchForm = document.getElementById('search-form');

        if (profileMenu) {
          profileMenu.addEventListener('click', e => {
            // only open modal if not authenticated (menu isn't a dropdown)
            if (!localStorage.getItem('token')) {
              e.preventDefault();
              const loginModalEl = document.getElementById('loginModal');
              if (loginModalEl && window.bootstrap && typeof window.bootstrap.Modal === 'function') {
                const modal = new bootstrap.Modal(loginModalEl);
                modal.show();
              }
            }
          });
        }

        if (loginForm) {
          loginForm.addEventListener('submit', async e => {
            e.preventDefault();
            const usernameEl = document.getElementById('username');
            const passwordEl = document.getElementById('password');
            const errorMessage = document.getElementById('errorMessage');

            const username = usernameEl?.value?.trim() || '';
            const password = passwordEl?.value || '';

            if (!username || !password) {
              if (errorMessage) {
                errorMessage.style.display = 'block';
                errorMessage.textContent = 'Please fill in all fields';
              }
              return;
            }

            try {
              const response = await login(username, password);
              const data = await response.json();
              if (!response.ok) throw new Error(data?.error?.message || 'Login failed');

              if (data.token) localStorage.setItem('token', data.token);
              if (data.refreshToken) localStorage.setItem('refreshToken', data.refreshToken);

              if (errorMessage) {
                errorMessage.style.display = 'none';
                errorMessage.textContent = '';
              }

              const loginModalEl = document.getElementById('loginModal');
              if (loginModalEl && window.bootstrap && bootstrap.Modal.getInstance(loginModalEl)) {
                bootstrap.Modal.getInstance(loginModalEl).hide();
              } else if (loginModalEl && window.bootstrap && typeof bootstrap.Modal === 'function') {
                // fallback: try to hide by creating an instance then hiding
                const m = new bootstrap.Modal(loginModalEl);
                m.hide();
              }

              // Prefer username from returned token payload (if present), else use the submitted username
              const newToken = data.token || localStorage.getItem('token');
              const payload = parseJwt(newToken);
              updateProfileMenu(payload.username || username);
            } catch (err) {
              if (errorMessage) {
                errorMessage.style.display = 'block';
                errorMessage.textContent = err.message || 'Login failed';
              }
            }
          });
        }

        if (searchForm) {
          searchForm.addEventListener('submit', async e => {
            e.preventDefault();
            const q = document.getElementById('search-input')?.value?.trim();
            const errorMessage = document.getElementById('errorMessage');

            if (!q || q.length < 2) {
              if (errorMessage) {
                errorMessage.style.display = 'block';
                errorMessage.textContent = 'Please enter at least 2 characters';
              }
              return;
            }

            try {
              const response = await search(q);
              if (!response.ok) {
                const data = await response.json().catch(() => ({}));
                throw new Error((data?.error?.message) || 'Search failed');
              }
              const results = await response.json();
              displaySearchResults(results, q);
              if (errorMessage) {
                errorMessage.style.display = 'none';
                errorMessage.textContent = '';
              }
            } catch (err) {
              if (errorMessage) {
                errorMessage.style.display = 'block';
                errorMessage.textContent = err.message || 'Search failed';
              }
            }
          });
        }
      }

      // Initialize when DOM ready
      window.addEventListener('DOMContentLoaded', () => {
        attachEventListeners();
        checkAuthStatus();
      });
    </script>
  </header>
    <div id="content" class="row">
  <div class="page-title" id="title-container">
    <h1 class="page-title" id="page-title">Loading…</h1>
    <h3 class="page-subtitle" id="label-list">Loading…</h3>
  </div>
  <div class="col-md-8">
    <div class="mt-3">
      <button id="editPropertiesBtn" class="btn btn-primary me-2" style="display: none;">Edit Properties</button>
      <button id="deleteNodeBtn" class="btn btn-danger" style="display: none;">Delete Node</button>
    </div>
    <div id="editPropertiesForm" class="mt-3" style="display: none;">
      <form id="updateForm">
        <div class="mb-3">
          <label class="form-label">Properties</label>
          <table class="table table-bordered" id="propertiesTable">
            <thead>
              <tr>
                <th>Property</th>
                <th>Value</th>
              </tr>
            </thead>
            <tbody id="properties"></tbody>
          </table>
        </div>
        <button type="button" class="btn btn-secondary" id="addProperty">Add Property</button>
        <div id="updateErrorMessage" class="text-danger mb-3" style="display: none;"></div>
        <button type="submit" class="btn btn-primary">Update Properties</button>
        <button type="button" class="btn btn-link" id="cancelEdit">Cancel</button>
      </form>
    </div>
    <div id="propertiesDisplay"></div>
    <div class="rels-section" id="outgoing-section" style="display:none;">
      <h3>Outgoing Relationships</h3>
      <ul class="rels-list" id="outgoing-list"></ul>
    </div>
    <div class="rels-section" id="incoming-section" style="display:none;">
      <h3>Incoming Relationships</h3>
      <ul class="rels-list" id="incoming-list"></ul>
    </div>
    <a href="#" id="createRelationshipBtn" class="btn btn-primary mt-3" style="display: none;">Create Relationship</a>
  </div>
  <aside class="col-md-4">
    <div class="infobox" id="infobox">
      <h4>Related Pages</h4>
      <table id="info-table"></table>
    </div>
  </aside>
</div>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>
<script>
  // Define special relationships map
  const specialRels = {
    incoming: {
      'EDITION_OF': 'Editions',
      'VERSION_OF': 'Versions',
      'DERIVED_FROM': 'Main Text',
      'TRANSLATION_OF': 'Translations',
      'TRANSLATED': 'Translators',
      'PUBLISHED': 'Publisher',
      'WROTE': 'Author',
      'DISPLAYS': 'Displayed On',
      'PUBLISHED_IN': 'Published',
      'HOSTS': 'Hosted By',
      'COMMENTARY_ON': 'Commentary'
    },
    outgoing: {
      'PUBLISHED_BY': 'Publishers',
      'PUBLISHED': 'Published',
      'EDITION_OF': 'Source Text',
      'VERSION_OF': 'A Version Of',
      'DERIVED_FROM': 'Derived From',
      'WROTE': 'Wrote',
      'PUBLISHED_IN': 'Published In',
      'TRANSLATED': 'Translated',
      'DISPLAYS': 'Displays',
      'HOSTS': 'Hosts',
      'COMMENTARY_ON': 'Commentary On'
    }
  };

  const params = new URLSearchParams(window.location.search);
  const type = params.get('label');
  const id = params.get('id');
  let nodeId = null;
  let propertyCount = 0;

  async function loadInfo() {
    if (!type || !id) {
      document.getElementById('page-title').textContent = 'Invalid parameters';
      document.getElementById('content').innerHTML = '<p class="text-danger">Missing type or ID</p>';
      return;
    }
    try {
      const nodeRes = await getNode(id);
      if (nodeRes.status === 401) {
        localStorage.removeItem('token');
        localStorage.removeItem('refreshToken');
        window.location.href = '/leabharlann/index.html';
        return;
      }
      if (!nodeRes.ok) throw new Error(`Failed to load node: ${await nodeRes.text()}`);
      const data = await nodeRes.json();
      if (!data) throw new Error('Node not found');
      nodeId = data.id;

      const relRes = await getRelations(id);
      if (!relRes.ok) throw new Error(`Failed to load relationships: ${await relRes.text()}`);
      const relData = await relRes.json();
      data.outgoing = relData.outgoing || [];
      data.incoming = relData.incoming || [];

      renderPage(data);
      updateAuthUI();
    } catch (error) {
      console.error('Load error:', error);
      document.getElementById('page-title').textContent = 'Error';
      document.getElementById('content').innerHTML = `<p class="text-danger">Error: ${error.message}</p>`;
    }
  }

  function updateAuthUI() {
    const isAuthenticated = !!localStorage.getItem('token');
    document.getElementById('createRelationshipBtn').style.display = isAuthenticated ? 'block' : 'none';
    document.getElementById('editPropertiesBtn').style.display = isAuthenticated ? 'block' : 'none';
    document.getElementById('deleteNodeBtn').style.display = isAuthenticated ? 'block' : 'none';
    document.querySelectorAll('.delete-property-btn').forEach(btn => {
      btn.style.display = isAuthenticated ? 'inline-block' : 'none';
    });
    document.querySelectorAll('.delete-rel-btn').forEach(btn => {
      btn.style.display = isAuthenticated ? 'inline-block' : 'none';
    });
  }

  function createRelListItem(rel, currentNodeId, direction, includeRelType = false) {
    const li = document.createElement('li');
    const a = document.createElement('a');
    const node = rel.node;
    const label = node.properties.display_name || node.properties.name || node.properties.title || node.properties.nodeId || node.id;
    const arrow = direction === 'outgoing' ? '→' : '←';
    a.textContent = includeRelType ? `${rel.type} ${arrow} ${label}` : label;
    a.href = `index.html?label=${typeFromLabel(node.labels)}&id=${encodeURIComponent(node.id)}`;
    li.appendChild(a);

    let payload = [((direction === 'incoming') ? node.id : currentNodeId), ((direction === 'incoming') ? currentNodeId : node.id), rel.type];
    li.appendChild(window.createDeleteButton(deleteRelationship, payload));

    return li;
  }

  function renderPage(data) {
    const title = data.properties.display_name || data.properties.name || data.properties.title || data.properties.nodeId || data.id;
    const labelList = data.labels.map(String).map(s => s.trim()).filter(s => s !== 'Entity');
    document.getElementById('page-title').textContent = title;
    document.getElementById('label-list').textContent = labelList.join(', ');
    document.getElementById('createRelationshipBtn').href = `/relationship/index.html?fromType=${encodeURIComponent(type)}&fromId=${encodeURIComponent(data.id)}`;
    const infoTable = document.getElementById('info-table');
    const propertiesDisplay = document.getElementById('propertiesDisplay');
    const dataSection = document.createElement('div');
    const dataTable = document.createElement('table');

    infoTable.innerHTML = '';
    propertiesDisplay.innerHTML = '';
    Object.entries(data.properties).forEach(([property, value]) => {
      // For certain properties we expect to be large or important, move them to the middle section of the page.
      if (['description', 'analysis'].includes(property)) {
        const section = document.createElement('div');
        section.className = 'data-section';
        section.innerHTML = `<h3 class="section-header">${window.cleanString(property)}</h3><p>${value}</p>`;
        propertiesDisplay.appendChild(section);
      } else {
        // For all other values, which are unimportant by comparison, move to a section at the bottom of the page.
        const tr = document.createElement('tr');
        const th = document.createElement('th');
        th.textContent = window.cleanString(property);
        const td = document.createElement('td');
        if (Array.isArray(value)) {
          value.forEach((item, idx) => {
            if (window.isUrl(item)) {
              const a = document.createElement('a');
              a.href = item;
              a.textContent = item;
              a.target = '_blank';
              td.appendChild(a);
            } else {
              td.appendChild(document.createTextNode(item));
            }
            if (idx < value.length - 1)
              td.appendChild(document.createTextNode(', '));
          });
        } else {
          if (typeof value === 'string' && window.isUrl(value)) {
            const a = document.createElement('a');
            a.href = value;
            a.textContent = value;
            a.target = '_blank';
            td.appendChild(a);
          } else {
            td.textContent = value || '';
          }
        }
        if (property !== 'nodeId' && property !== 'createdBy') {
          const deleteTd = document.createElement('td');
          deleteTd.appendChild(window.createDeleteButton(deleteProperty, [property]));
          tr.appendChild(deleteTd);
        }
        tr.prepend(td);
        tr.prepend(th);
        dataTable.appendChild(tr);
      }
    });

    if (dataTable.childElementCount > 0) {
      const header = document.createElement('h3');
      header.className = 'section-header';
      header.textContent = 'Details';
      dataSection.appendChild(header);
      dataSection.appendChild(dataTable);
      propertiesDisplay.appendChild(dataSection);
    }

    // Populate edit form
    const propertiesTbody = document.getElementById('properties');
    propertiesTbody.innerHTML = '';
    propertyCount = 0;
    Object.entries(data.properties).forEach(([k, v]) => {
      if (k === 'nodeId' || k === 'createdBy') return;
      const row = document.createElement('tr');
      row.className = 'property-row';
      row.innerHTML = `
        <td><input type="text" class="form-control" name="prop-name-${propertyCount}" value="${k}" readonly></td>
        <td><input type="text" class="form-control" name="prop-value-${propertyCount}" value="${v || ''}"></td>
      `;
      propertiesTbody.appendChild(row);
      propertyCount++;
    });

    // Process relationships
    const contentDiv = document.querySelector('#content .col-md-8');
    const outgoingSection = document.getElementById('outgoing-section');
    const incomingSection = document.getElementById('incoming-section');
    const infoBox = document.getElementById('infobox');

    // Clear any existing dynamically added sections
    const existingSections = contentDiv.querySelectorAll('.rels-section:not(#outgoing-section):not(#incoming-section)');
    existingSections.forEach(section => section.remove());

    // Handle special incoming relationships
    for (const [relType, header] of Object.entries(specialRels.incoming)) {
      const rels = data.incoming.filter(r => r.type === relType);
      if (rels.length > 0) {
        const section = document.createElement('div');
        section.className = 'rels-section';
        section.innerHTML = `<h3>${header}</h3><ul class="rels-list"></ul>`;
        const list = section.querySelector('.rels-list');
        rels.forEach(rel => {
          const li = createRelListItem(rel, data.id, 'incoming', false);
          list.appendChild(li);
        });
        infoBox.insertBefore(section, infoTable);
      }
    }

    // Handle special outgoing relationships
    for (const [relType, header] of Object.entries(specialRels.outgoing)) {
      const rels = data.outgoing.filter(r => r.type === relType);
      if (rels.length > 0) {
        const section = document.createElement('div');
        section.className = 'rels-section';
        section.innerHTML = `<h3>${header}</h3><ul class="rels-list"></ul>`;
        const list = section.querySelector('.rels-list');
        rels.forEach(rel => {
          const li = createRelListItem(rel, data.id, 'outgoing', false);
          list.appendChild(li);
        });
        infoBox.insertBefore(section, infoTable);
      }
    }

    // Handle general incoming relationships
    const specialIncomingTypes = Object.keys(specialRels.incoming);
    const generalIncoming = data.incoming.filter(r => !specialIncomingTypes.includes(r.type));
    if (generalIncoming.length > 0) {
      incomingSection.style.display = '';
      const inList = document.getElementById('incoming-list');
      inList.innerHTML = '';
      generalIncoming.forEach(rel => {
        const li = createRelListItem(rel, data.id, 'incoming', true);
        inList.appendChild(li);
      });
    } else {
      incomingSection.style.display = 'none';
    }

    // Handle general outgoing relationships
    const specialOutgoingTypes = Object.keys(specialRels.outgoing);
    const generalOutgoing = data.outgoing.filter(r => !specialOutgoingTypes.includes(r.type));
    if (generalOutgoing.length > 0) {
      outgoingSection.style.display = '';
      const outList = document.getElementById('outgoing-list');
      outList.innerHTML = '';
      generalOutgoing.forEach(rel => {
        const li = createRelListItem(rel, data.id, 'outgoing', true);
        outList.appendChild(li);
      });
    } else {
      outgoingSection.style.display = 'none';
    }
  }

  async function deleteNode() {
    if (!confirm('Are you sure you want to delete this node and all its relationships?')) return;
    try {
      const response = await deleteNode(nodeId);
      if (!response.ok) throw new Error((await response.json()).error.message || 'Failed to delete node');
    } catch (error) {
      document.getElementById('updateErrorMessage').style.display = 'block';
      document.getElementById('updateErrorMessage').textContent = error.message;
    }
  }

  async function deleteProperty(key) {
    if (!confirm(`Are you sure you want to delete the property "${key}"?`)) return;
    try {
      const token = localStorage.getItem('token');
      if (!token) throw new Error('Not authenticated');
      const response = await fetch(`${API_BASE}/nodes/${encodeURIComponent(nodeId)}/property/${encodeURIComponent(key)}`, {
        method: 'DELETE',
        headers: { 'Authorization': `Bearer ${token}` }
      });
      if (!response.ok) throw new Error((await response.json()).error.message || 'Failed to delete property');
      const data = await response.json();
      const relRes = await fetch(`${API_BASE}/nodes/${encodeURIComponent(nodeId)}/relations`, {
        headers: { 'Authorization': `Bearer ${token}` }
      });
      if (!relRes.ok) throw new Error(`Failed to load relationships: ${await relRes.text()}`);
      const relData = await relRes.json();
      data.outgoing = relData.outgoing || [];
      data.incoming = relData.incoming || [];
      renderPage(data);
    } catch (error) {
      document.getElementById('updateErrorMessage').style.display = 'block';
      document.getElementById('updateErrorMessage').textContent = error.message;
    }
  }

  async function deleteRelationship(sourceNodeId, targetNodeId, relType) {
    console.log(sourceNodeId + "---" + targetNodeId + "---" + relType);
    if (!confirm('Are you sure you want to delete this relationship?')) return;
    try {
      const token = localStorage.getItem('token');
      if (!token) throw new Error('Not authenticated');
      const response = await fetch(`${API_BASE}/relation`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ sourceNodeId, targetNodeId, relType })
      });
      if (!response.ok) throw new Error((await response.json()).error.message || 'Failed to delete relationship');
      const nodeRes = await fetch(`${API_BASE}/nodes/${encodeURIComponent(nodeId)}`, {
        headers: { 'Authorization': `Bearer ${token}` }
      });
      if (!nodeRes.ok) throw new Error(`Failed to load node: ${await nodeRes.text()}`);
      const data = await nodeRes.json();
      const relRes = await fetch(`${API_BASE}/nodes/${encodeURIComponent(nodeId)}/relations`, {
        headers: { 'Authorization': `Bearer ${token}` }
      });
      if (!relRes.ok) throw new Error(`Failed to load relationships: ${await relRes.text()}`);
      const relData = await relRes.json();
      data.outgoing = relData.outgoing || [];
      data.incoming = relData.incoming || [];
      renderPage(data);
    } catch (error) {
      document.getElementById('updateErrorMessage').style.display = 'block';
      document.getElementById('updateErrorMessage').textContent = error.message;
    }
  }

  function typeFromLabel(labels) {
    if (!labels || !labels.length) return type || 'node';
    return labels.find(label => label !== 'Entity') || 'node';
  }

  document.getElementById('editPropertiesBtn').addEventListener('click', () => {
    document.getElementById('editPropertiesForm').style.display = 'block';
    document.getElementById('editPropertiesBtn').style.display = 'none';
    document.getElementById('deleteNodeBtn').style.display = 'none';
    document.getElementById('propertiesDisplay').style.display = 'none';
  });

  document.getElementById('cancelEdit').addEventListener('click', () => {
    document.getElementById('editPropertiesForm').style.display = 'none';
    document.getElementById('editPropertiesBtn').style.display = localStorage.getItem('token') ? 'block' : 'none';
    document.getElementById('deleteNodeBtn').style.display = localStorage.getItem('token') ? 'block' : 'none';
    document.getElementById('propertiesDisplay').style.display = 'block';
  });

  document.getElementById('addProperty').addEventListener('click', () => {
    const tbody = document.getElementById('properties');
    const row = document.createElement('tr');
    row.className = 'property-row';
    row.innerHTML = `
      <td><input type="text" class="form-control" name="prop-name-${propertyCount}" placeholder="e.g., name, title"></td>
      <td><input type="text" class="form-control" name="prop-value-${propertyCount}"></td>
    `;
    tbody.appendChild(row);
    propertyCount++;
  });

  document.getElementById('deleteNodeBtn').addEventListener('click', deleteNode);

  document.getElementById('updateForm').addEventListener('submit', async e => {
    e.preventDefault();
    const properties = {};
    let invalidProp = false;
    document.querySelectorAll('.property-row').forEach((row, index) => {
      let name = row.querySelector(`[name="prop-name-${index}"]`).value.trim();
      let value = row.querySelector(`[name="prop-value-${index}"]`).value.trim();
      const splitProperties = ['ext_link'];
      if (splitProperties.includes(name) && value.includes(', '))
        value = value.split(', ').map(item => item.trim());
      if (name) {
        if (/[^a-zA-Z0-9_]/.test(name) || name === 'nodeId' || name === 'createdBy') {
          invalidProp = true;
          return;
        }
        properties[name] = value || null;
      }
    });
    if (invalidProp) {
      document.getElementById('updateErrorMessage').style.display = 'block';
      document.getElementById('updateErrorMessage').textContent = 'Property names can only contain letters, numbers, underscores, and cannot be nodeId or createdBy';
      return;
    }
    try {
      const token = localStorage.getItem('token');
      if (!token) {
        window.location.href = 'index.html';
        return;
      }
      const response = await fetch(`${API_BASE}/nodes/${encodeURIComponent(nodeId)}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({ properties })
      });
      const data = await response.json();
      if (!response.ok) throw new Error(data.error.message || 'Failed to update node');
      document.getElementById('updateErrorMessage').style.display = 'none';
      document.getElementById('editPropertiesForm').style.display = 'none';
      document.getElementById('editPropertiesBtn').style.display = 'block';
      document.getElementById('deleteNodeBtn').style.display = 'block';
      document.getElementById('propertiesDisplay').style.display = 'block';

      const relRes = await fetch(`${API_BASE}/nodes/${encodeURIComponent(nodeId)}/relations`, {
        headers: { 'Authorization': `Bearer ${token}` }
      });
      if (!relRes.ok) throw new Error(`Failed to load relationships: ${await relRes.text()}`);
      const relData = await relRes.json();
      data.outgoing = relData.outgoing || [];
      data.incoming = relData.incoming || [];
      renderPage(data);
    } catch (error) {
      document.getElementById('updateErrorMessage').style.display = 'block';
      document.getElementById('updateErrorMessage').textContent = error.message;
    }
  });

  window.addEventListener('DOMContentLoaded', () => {
    loadInfo();
    document.addEventListener('authChange', updateAuthUI);
  });
</script>

  </body>
</html>